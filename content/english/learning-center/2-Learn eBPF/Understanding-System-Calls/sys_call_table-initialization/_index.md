---
title: "System Call Table Initialization"
date: 2023-09-22
draft: false
# description
description: "Explore in-depth insights into Linux system calls with our comprehensive series of blogs. Delve into the intricacies of syscalls, from their initiation to their interaction with the Linux kernel, uncovering the technical layers and methodologies. Whether you're a seasoned developer or a budding enthusiast, traverse through the realms of system call tables, fast system calls, and more, enhancing your understanding of Linux's core functionalities. Dive deep into the world of system calls, understand varied architectures, and grasp the kernel interactions for optimized software development and enriched knowledge in system-level programming."
type : "learning-center"
weight: 12
---

### Introduction:
The Linux kernel utilizes a system call table, `sys_call_table`, to manage system call handlers, where each element of the array is a pointer to a system call handler function. This article delves into the technical aspects of initializing the `sys_call_table` in Linux, focusing on how non-implemented system calls are handled and how the array elements are initialized using Designated Initializers, a GCC compiler extension.

### Initialization of `sys_call_table`:
The `sys_call_table` is initialized such that all elements of the array pointing to the system call handlers, initially point to the `sys_ni_syscall` function. This function represents the handlers for not-implemented system calls. In essence, when the system call table is first created, all the system calls are marked as not implemented.
```c
[0 ... __NR_syscall_max] = &sys_ni_syscall,
```
### The `sys_ni_syscall` Function:
The `sys_ni_syscall` function is straightforward in its implementation. It simply returns -ENOSYS, indicating that the system call is not implemented.
```c
long sys_ni_syscall(void)
{
    return -ENOSYS;
}
```

### Use of Designated Initializers:
The GCC compiler extension, Designated Initializers, allows for the initialization of elements in a non-fixed order within the array. This means the `sys_call_table` array elements can be initialized in any order, offering a degree of flexibility during the initialization phase.

### Inclusion of `asm/syscalls_64.h`:
The `asm/syscalls_64.h` header is included at the end of the array. This header file is generated by a special script located at `arch/x86/entry/syscalls/syscalltbl.sh`. This script generates the header file from the system call table, defining the actual handlers for each implemented system call.
```c
#include <asm/syscalls_64.h>
```
The generated header files can be found at:
- `./arch/x86/include/generated/asm/syscalls_64.h`
- `./arch/x86/include/generated/asm/syscalls_32.h`

### Conclusion:
The initialization of the `sys_call_table` in the Linux kernel is a crucial step in managing system calls. Initially, all elements of the array point to `sys_ni_syscall`, representing not-implemented system calls. The use of Designated Initializers enables flexible initialization of the array elements, and the inclusion of generated header files like `asm/syscalls_64.h` ties the actual implemented system call handlers to the table, ensuring seamless interaction between user-space applications and the kernel.

### Key Takeaways:
- The `sys_call_table` is initialized with all elements pointing to `sys_ni_syscall`.
- `sys_ni_syscall` represents not-implemented system calls and returns -ENOSYS.
- Designated Initializers allow initializing array elements in a non-fixed order.
- The `asm/syscalls_64.h` header, generated by a special script, is included to define actual handlers for implemented system calls.

### References:
- Linux Kernel Source: arch/x86/entry/syscall_64.c
- GCC Compiler Extension: Designated Initializers
- Linux Kernel Documentation
